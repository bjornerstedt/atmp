---
title: "Untitled"
author: "Jonas Björnerstedt"
date: "`r Sys.Date()`"
output: html_document
---


```{r setup, include=FALSE}
library(tidyverse)
library(readxl)
library(knitr)
library(shiny)
library(kableExtra)
library(flextable)

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
options(dplyr.summarise.inform = FALSE)
options(knitr.kable.NA = '') # Suppress printing of NA in kable
# Standard theme for document 
theme_set(theme_bw()) 

set_flextable_defaults(
align = "center",
digits = 2
# theme_fun = theme_zebra
  )

doShiny = TRUE

source("atmp.R")

# Läs in från Excel
# source("create_settings.R")
example_simple = open_indata("simple.xlsx")
exampleA = open_indata("Example_A.xlsx")
exampleB = open_indata("Example_B.xlsx")
exampleA2 = open_indata("Example_A2.xlsx")

```


## Title

# State table version

```{r}
state_tableA = read_csv("
treatment,    state,    pr.prog,   QoL,  p_death, payment
ATMP,         1,        0.05,     1.0,    0.01,   ATMP
ATMP,         2,        1.00,        ,    0.02,   Comparison
ATMP,         6,        0.00,     0.0,    0.00,
Comparison,   1,        1.00,     1.0,    0.02,   Comparison
Comparison,   6,        0.00,     0.0,    0.00,   
")
state_tableA %>% flextable_output()
```

* Omit QoL and it is linear

* Can specify QoL at transition instead of NA. Can also specify QoL for each state.

* If state is omitted, it is set to the next value. Useful for example 3 and for omitting state completely.

* Omit p_death and it is set with real hazard

* Lägg till arm kolumn om det är fler än två treatments

```{r, eval=TRUE}
exampleA$contract_table %>% 
  select(-plan, -start, -end) %>% 
  rename(payment_plan = name) %>% 
  flextable_output()   
```

## Example B

```{r}
state_tableB = read_csv("
treatment,    state,    pr.prog,   QoL,  p_death, payment
ATMP,         1,        0.05,      0.9,    0.02,   ATMP
ATMP,         2,        0,         0.8,    0.02,   Comparison
ATMP,         3,        0,        0.0,    0.00,
Comparison,   1,        0,        0.8,    0.02,   Comparison
Comparison,   2,        0,        0.0,    0.00,   
")
state_tableB %>% flextable_output()
```

## Example C

```{r}
state_tableC = read_csv("
treatment,    state,    pr.prog,   QoL,  p_death, payment
ATMP,         1,        1.00,      1.0,    0.02,   Comparison
ATMP,         2,        0.05,         ,    0.01,   ATMP
ATMP,         3,        1.00,         ,    0.02,   Comparison
ATMP,         6,        0.00,     0.0,    0.00,
Comparison,   1,        1.00,     1.0,    0.02,    Comparison
Comparison,   6,        0.00,     0.0,    0.00,   
")
state_tableC %>% flextable_output()
```

# Create full table

```{r}
indata = state_tableA %>% filter(treatment == "ATMP") 
indata$QoL[2] = 0.6
indata
```

Check input 

```{r}
indata$state[[1]] == 1
```

Fill state table and create item variable - could be useful in payments that continue over states

```{r}
create_state_table = function(indata) {
indata  %>% group_by(treatment) %>% 
  mutate(QoLstate = pmax(state, QoL), QoLnext = replace_na(lead(QoL), 0)) %>% fill(QoLstate) %>%  # Get QoLstate
  mutate(periods = replace_na(lead(state) - state, 1)) %>% fill(QoL) %>% 
  uncount(periods) %>% mutate(item = state, state = row_number()) %>% 
  group_by(treatment, QoLstate) %>% 
  mutate(QoL = QoL - (QoL - QoLnext)*(row_number() - 1 )/n() ) %>% 
  ungroup() %>% 
  select(-QoLstate, -QoLnext)
}
state_table = create_state_table(state_tableA) %>% 
  filter(treatment == "ATMP")
state_table 
```

```{r}
transition_matrix <- function(state_table) {
  state_table = state_table
  health_states = max(state_table$state)
  P = matrix(0, health_states, health_states)
  for (i in 1:(health_states-1)) {
    P[i, i] = 1 - state_table$pr.prog[i] 
    P[i, i + 1] = state_table$pr.prog[i] - state_table$p_death[i]
    P[i, health_states] =  P[i, health_states] + state_table$p_death[i] 
  }
  P[health_states, health_states] = 1
  rownames(P) = colnames(P) = c(sprintf("S%d", 1:(health_states - 1)), "D")
  P
}

P = transition_matrix(state_table) 
P
```

```{r}
get_QoL <- function(state_table) {
  state_table %>% pull(QoL)
  # if (tr$QoL_end > 0) {
  #   QoL = c(seq(tr$QoL_start, tr$QoL_end, length.out = tr$health_states-1), 0)
  # } else {
  #   QoL = seq(tr$QoL_start, tr$QoL_end, length.out = tr$health_states)
  # }
  # QoL
}
get_QoL(state_table) 

```

```{r}
  states = expected_markov( P, 20)
states
```

For continuous payments, we can calculate costs by simply creating a cost vector - payment per state

For multi-period payments with certain starting time we can do the same as we know the time and the share entering the ATMP state. 

# Contracts

```{r}
contract_description = read_csv("
name, title, value,               description
payment, Payment plan, ,            Payment name
tot_payment,  Tot. payment, 0,     Total payment or yearly paymentif payment is continuous
cont_payment, Cont. payment, 0, Payment each year that the patient is alive (traditional) 
cost_trend, Cost Trend,      0, Cost trend over time - for continuous payment
contract_length, Periods,   20, Total length of contract
initial_payment, Initial,   0,    Share of payment in initial period
refund, Refund,             0, Share of payments refunded upon failure (progression)
aggregate_failure, Agg. Fail, 0, Threshold share of population for aggregate failure
")

# treatment_table = read_csv("
# treatment, p_HU, health_states
# ATMP,              0.04, 4
# Comparison,        1, 4
# ") 

contract_table = read_csv("
payment,tot_payment, cont_payment,     contract_length
ATMP,10,0,        10
Comparison,0,0.5, 
") 

global_table = read_csv("
name, value
discount, 0.0
firm_discount, 0.0
time_horizon, 20
threshold, 1
active_plan, 1
control_plan, 0
"
) 
```

Perhaps start should be called state, to confirm to new structure


```{r}
named_list <- function(table, name, value) {
  ret = as.list(table[[value]])
  names(ret) = table[[name]]
  ret  
}
```

Single contract as list with defaults

```{r}
con_def = named_list(contract_description, "name", "value")
globals = named_list(global_table, "name", "value")

con = modifyList(con_def, 
        contract_table %>% slice(1) %>% transpose() %>% pluck(1)
      )

```

```{r}
con$start =15
payment_plan(con, globals)
```

```{r}
con1 = state_table %>% 
  left_join(contract_table) %>% 
  mutate_if(is.numeric, list(~replace_na(., 0))) %>% 
  mutate(start = state, payment = replace_na(payment, "Death")) 

con1
```

Depends on con1 rather than on state_table

```{r}
con = modifyList(con_def, 
        con1 %>% slice(1) %>% transpose() %>% pluck(1)
      )
con$start = con$state
payment_plan(con, globals)

```



```{r}
create_payment_plans <- function(state_table, contract_table, globals) {
  
  cons = state_table %>% 
    left_join(contract_table) %>% 
    mutate_if(is.numeric, list(~replace_na(., 0))) %>% 
    mutate(start = state, payment = replace_na(payment, "Death"))
  
  ret = c()
  for (i in 1:nrow(cons)) {
    con = cons %>% slice(i)  %>% as.list() %>% 
      modifyList(con_def, .)
    ret = c(ret, payment_plan(con, globals))
  }
  ret = matrix(ret, ncol = nrow(con1))
  ret
}

create_payment_plans(state_table, contract_table, globals)

```


```{r}
state_table
```

```{r}
analyse_treatment <- function(state_table, contract_table, globals) {
  
P = transition_matrix(state_table) 
  
  states = expected_markov( P, globals$time_horizon)

  # CALCULATE COSTS AND QALY
  costs =  create_payment_plans(state_table, contract_table, globals) * states

  QALY = as.vector( states %*% get_QoL(state_table)) * 
    discounting(globals$discount, globals$time_horizon)
    
   # Put into dataset and sum costs over states 
   ret = tibble()
     costs_df = costs %>% 
      as_tibble() %>% 
      mutate(time = row_number()) %>% 
      pivot_longer(-time, names_to = "state", values_to = "value", names_prefix = "S", names_transform = as.integer) %>% 
      left_join(state_table %>% select(state, costben = payment)) %>% 
      filter(!is.na(costben)) %>% 
      group_by(time, costben) %>% summarise(value = sum(value))

    ret = bind_rows(ret,
      bind_rows(costs_df, tibble(time = 1:length(QALY), costben = "QALY", value = QALY) ) %>% 
        add_column( treatment = state_table$treatment[[1]], .before = 1)
    )
    ret
}

analyse_treatment(state_table, contract_table, globals) 

```

```{r}
analyse_treatments <- function(state_table, contract_table, globals, over_time = FALSE) {
  state_table_all = create_state_table(state_table) 
  
  treats = state_table_all %>% distinct(treatment) %>% pull()
  ret = tibble()
  for (i in 1:length(treats)) {
    state_table_i = state_table_all %>% filter(treatment == treats[i])
      ret = bind_rows(ret, analyse_treatment(state_table_i, contract_table, globals))
  }
  ret
}

create_state_table(state_tableA) %>% analyse_treatments(contract_table, globals, over_time = FALSE)
```


```{r, eval=FALSE}
state_table = create_state_table(state_tableA) %>% 
  group_by(treatment) %>% 
  nest() %>% 
  analyse_treatment(contract_table) %>% 
  unnest()

  

```




